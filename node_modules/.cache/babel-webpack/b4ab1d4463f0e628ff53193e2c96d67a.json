{"ast":null,"code":"/**\r\n * @param {string} value\r\n * @returns {RegExp}\r\n * */\n\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n  return re.source;\n}\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\n\n\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n/**\r\n * @param {...(RegExp | string) } args\r\n * @returns {string}\r\n */\n\n\nfunction concat(...args) {\n  const joined = args.map(x => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n/**\r\n * Any of the passed expresssions may match\r\n *\r\n * Creates a huge this | this | that | that match\r\n * @param {(RegExp | string)[] } args\r\n * @returns {string}\r\n */\n\n\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' + (opts.capture ? \"\" : \"?:\") + args.map(x => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\nconst keywordWrapper = keyword => concat(/\\b/, keyword, /\\w$/.test(keyword) ? /\\b/ : /\\B/); // Keywords that require a leading dot.\n\n\nconst dotKeywords = ['Protocol', // contextual\n'Type' // contextual\n].map(keywordWrapper); // Keywords that may have a leading dot.\n\nconst optionalDotKeywords = ['init', 'self'].map(keywordWrapper); // should register as keyword, not type\n\nconst keywordTypes = ['Any', 'Self']; // Regular keywords and literals.\n\nconst keywords = [// strings below will be fed into the regular `keywords` engine while regex\n// will result in additional modes being created to scan for those keywords to\n// avoid conflicts with other rules\n'actor', 'associatedtype', 'async', 'await', /as\\?/, // operator\n/as!/, // operator\n'as', // operator\n'break', 'case', 'catch', 'class', 'continue', 'convenience', // contextual\n'default', 'defer', 'deinit', 'didSet', // contextual\n'do', 'dynamic', // contextual\n'else', 'enum', 'extension', 'fallthrough', /fileprivate\\(set\\)/, 'fileprivate', 'final', // contextual\n'for', 'func', 'get', // contextual\n'guard', 'if', 'import', 'indirect', // contextual\n'infix', // contextual\n/init\\?/, /init!/, 'inout', /internal\\(set\\)/, 'internal', 'in', 'is', // operator\n'isolated', // contextual\n'nonisolated', // contextual\n'lazy', // contextual\n'let', 'mutating', // contextual\n'nonmutating', // contextual\n/open\\(set\\)/, // contextual\n'open', // contextual\n'operator', 'optional', // contextual\n'override', // contextual\n'postfix', // contextual\n'precedencegroup', 'prefix', // contextual\n/private\\(set\\)/, 'private', 'protocol', /public\\(set\\)/, 'public', 'repeat', 'required', // contextual\n'rethrows', 'return', 'set', // contextual\n'some', // contextual\n'static', 'struct', 'subscript', 'super', 'switch', 'throws', 'throw', /try\\?/, // operator\n/try!/, // operator\n'try', // operator\n'typealias', /unowned\\(safe\\)/, // contextual\n/unowned\\(unsafe\\)/, // contextual\n'unowned', // contextual\n'var', 'weak', // contextual\n'where', 'while', 'willSet' // contextual\n]; // NOTE: Contextual keywords are reserved only in specific contexts.\n// Ideally, these should be matched using modes to avoid false positives.\n// Literals.\n\nconst literals = ['false', 'nil', 'true']; // Keywords used in precedence groups.\n\nconst precedencegroupKeywords = ['assignment', 'associativity', 'higherThan', 'left', 'lowerThan', 'none', 'right']; // Keywords that start with a number sign (#).\n// #available is handled separately.\n\nconst numberSignKeywords = ['#colorLiteral', '#column', '#dsohandle', '#else', '#elseif', '#endif', '#error', '#file', '#fileID', '#fileLiteral', '#filePath', '#function', '#if', '#imageLiteral', '#keyPath', '#line', '#selector', '#sourceLocation', '#warn_unqualified_access', '#warning']; // Global functions in the Standard Library.\n\nconst builtIns = ['abs', 'all', 'any', 'assert', 'assertionFailure', 'debugPrint', 'dump', 'fatalError', 'getVaList', 'isKnownUniquelyReferenced', 'max', 'min', 'numericCast', 'pointwiseMax', 'pointwiseMin', 'precondition', 'preconditionFailure', 'print', 'readLine', 'repeatElement', 'sequence', 'stride', 'swap', 'swift_unboxFromSwiftValueWithType', 'transcode', 'type', 'unsafeBitCast', 'unsafeDowncast', 'withExtendedLifetime', 'withUnsafeMutablePointer', 'withUnsafePointer', 'withVaList', 'withoutActuallyEscaping', 'zip']; // Valid first characters for operators.\n\nconst operatorHead = either(/[/=\\-+!*%<>&|^~?]/, /[\\u00A1-\\u00A7]/, /[\\u00A9\\u00AB]/, /[\\u00AC\\u00AE]/, /[\\u00B0\\u00B1]/, /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/, /[\\u2016-\\u2017]/, /[\\u2020-\\u2027]/, /[\\u2030-\\u203E]/, /[\\u2041-\\u2053]/, /[\\u2055-\\u205E]/, /[\\u2190-\\u23FF]/, /[\\u2500-\\u2775]/, /[\\u2794-\\u2BFF]/, /[\\u2E00-\\u2E7F]/, /[\\u3001-\\u3003]/, /[\\u3008-\\u3020]/, /[\\u3030]/); // Valid characters for operators.\n\nconst operatorCharacter = either(operatorHead, /[\\u0300-\\u036F]/, /[\\u1DC0-\\u1DFF]/, /[\\u20D0-\\u20FF]/, /[\\uFE00-\\uFE0F]/, /[\\uFE20-\\uFE2F]/ // TODO: The following characters are also allowed, but the regex isn't supported yet.\n// /[\\u{E0100}-\\u{E01EF}]/u\n); // Valid operator.\n\nconst operator = concat(operatorHead, operatorCharacter, '*'); // Valid first characters for identifiers.\n\nconst identifierHead = either(/[a-zA-Z_]/, /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/, /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/, /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/, /[\\u1E00-\\u1FFF]/, /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/, /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/, /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/, /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/, /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/, /[\\uFE47-\\uFEFE\\uFF00-\\uFFFD]/ // Should be /[\\uFE47-\\uFFFD]/, but we have to exclude FEFF.\n// The following characters are also allowed, but the regexes aren't supported yet.\n// /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\n// /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\n// /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\n// /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\n); // Valid characters for identifiers.\n\nconst identifierCharacter = either(identifierHead, /\\d/, /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/); // Valid identifier.\n\nconst identifier = concat(identifierHead, identifierCharacter, '*'); // Valid type identifier.\n\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*'); // Built-in attributes, which are highlighted as keywords.\n// @available is handled separately.\n\nconst keywordAttributes = ['autoclosure', concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/), 'discardableResult', 'dynamicCallable', 'dynamicMemberLookup', 'escaping', 'frozen', 'GKInspectable', 'IBAction', 'IBDesignable', 'IBInspectable', 'IBOutlet', 'IBSegueAction', 'inlinable', 'main', 'nonobjc', 'NSApplicationMain', 'NSCopying', 'NSManaged', concat(/objc\\(/, identifier, /\\)/), 'objc', 'objcMembers', 'propertyWrapper', 'requires_stored_property_inits', 'resultBuilder', 'testable', 'UIApplicationMain', 'unknown', 'usableFromInline']; // Contextual keywords used in @available and #available.\n\nconst availabilityKeywords = ['iOS', 'iOSApplicationExtension', 'macOS', 'macOSApplicationExtension', 'macCatalyst', 'macCatalystApplicationExtension', 'watchOS', 'watchOSApplicationExtension', 'tvOS', 'tvOSApplicationExtension', 'swift'];\n/*\r\nLanguage: Swift\r\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\r\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\r\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\r\nWebsite: https://swift.org\r\nCategory: common, system\r\n*/\n\n/** @type LanguageFn */\n\nfunction swift(hljs) {\n  const WHITESPACE = {\n    match: /\\s+/,\n    relevance: 0\n  }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\n\n  const BLOCK_COMMENT = hljs.COMMENT('/\\\\*', '\\\\*/', {\n    contains: ['self']\n  });\n  const COMMENTS = [hljs.C_LINE_COMMENT_MODE, BLOCK_COMMENT]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\n\n  const DOT_KEYWORD = {\n    match: [/\\./, either(...dotKeywords, ...optionalDotKeywords)],\n    className: {\n      2: \"keyword\"\n    }\n  };\n  const KEYWORD_GUARD = {\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\n    match: concat(/\\./, either(...keywords)),\n    relevance: 0\n  };\n  const PLAIN_KEYWORDS = keywords.filter(kw => typeof kw === 'string').concat([\"_|0\"]); // seems common, so 0 relevance\n\n  const REGEX_KEYWORDS = keywords.filter(kw => typeof kw !== 'string') // find regex\n  .concat(keywordTypes).map(keywordWrapper);\n  const KEYWORD = {\n    variants: [{\n      className: 'keyword',\n      match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\n    }]\n  }; // find all the regular keywords\n\n  const KEYWORDS = {\n    $pattern: either(/\\b\\w+/, // regular keywords\n    /#\\w+/ // number keywords\n    ),\n    keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),\n    literal: literals\n  };\n  const KEYWORD_MODES = [DOT_KEYWORD, KEYWORD_GUARD, KEYWORD]; // https://github.com/apple/swift/tree/main/stdlib/public/core\n\n  const BUILT_IN_GUARD = {\n    // Consume .built_in to prevent highlighting properties and methods.\n    match: concat(/\\./, either(...builtIns)),\n    relevance: 0\n  };\n  const BUILT_IN = {\n    className: 'built_in',\n    match: concat(/\\b/, either(...builtIns), /(?=\\()/)\n  };\n  const BUILT_INS = [BUILT_IN_GUARD, BUILT_IN]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\n\n  const OPERATOR_GUARD = {\n    // Prevent -> from being highlighting as an operator.\n    match: /->/,\n    relevance: 0\n  };\n  const OPERATOR = {\n    className: 'operator',\n    relevance: 0,\n    variants: [{\n      match: operator\n    }, {\n      // dot-operator: only operators that start with a dot are allowed to use dots as\n      // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\n      // characters that may also include dots.\n      match: `\\\\.(\\\\.|${operatorCharacter})+`\n    }]\n  };\n  const OPERATORS = [OPERATOR_GUARD, OPERATOR]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\n\n  const decimalDigits = '([0-9]_*)+';\n  const hexDigits = '([0-9a-fA-F]_*)+';\n  const NUMBER = {\n    className: 'number',\n    relevance: 0,\n    variants: [// decimal floating-point-literal (subsumes decimal-literal)\n    {\n      match: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b`\n    }, // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\n    {\n      match: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b`\n    }, // octal-literal\n    {\n      match: /\\b0o([0-7]_*)+\\b/\n    }, // binary-literal\n    {\n      match: /\\b0b([01]_*)+\\b/\n    }]\n  }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\n\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    variants: [{\n      match: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/)\n    }, {\n      match: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/)\n    }]\n  });\n\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    match: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\n  });\n\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    label: \"interpol\",\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\n    end: /\\)/\n  });\n\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"\"\"/),\n    end: concat(/\"\"\"/, rawDelimiter),\n    contains: [ESCAPED_CHARACTER(rawDelimiter), ESCAPED_NEWLINE(rawDelimiter), INTERPOLATION(rawDelimiter)]\n  });\n\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"/),\n    end: concat(/\"/, rawDelimiter),\n    contains: [ESCAPED_CHARACTER(rawDelimiter), INTERPOLATION(rawDelimiter)]\n  });\n\n  const STRING = {\n    className: 'string',\n    variants: [MULTILINE_STRING(), MULTILINE_STRING(\"#\"), MULTILINE_STRING(\"##\"), MULTILINE_STRING(\"###\"), SINGLE_LINE_STRING(), SINGLE_LINE_STRING(\"#\"), SINGLE_LINE_STRING(\"##\"), SINGLE_LINE_STRING(\"###\")]\n  }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\n\n  const QUOTED_IDENTIFIER = {\n    match: concat(/`/, identifier, /`/)\n  };\n  const IMPLICIT_PARAMETER = {\n    className: 'variable',\n    match: /\\$\\d+/\n  };\n  const PROPERTY_WRAPPER_PROJECTION = {\n    className: 'variable',\n    match: `\\\\$${identifierCharacter}+`\n  };\n  const IDENTIFIERS = [QUOTED_IDENTIFIER, IMPLICIT_PARAMETER, PROPERTY_WRAPPER_PROJECTION]; // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\n\n  const AVAILABLE_ATTRIBUTE = {\n    match: /(@|#)available/,\n    className: \"keyword\",\n    starts: {\n      contains: [{\n        begin: /\\(/,\n        end: /\\)/,\n        keywords: availabilityKeywords,\n        contains: [...OPERATORS, NUMBER, STRING]\n      }]\n    }\n  };\n  const KEYWORD_ATTRIBUTE = {\n    className: 'keyword',\n    match: concat(/@/, either(...keywordAttributes))\n  };\n  const USER_DEFINED_ATTRIBUTE = {\n    className: 'meta',\n    match: concat(/@/, identifier)\n  };\n  const ATTRIBUTES = [AVAILABLE_ATTRIBUTE, KEYWORD_ATTRIBUTE, USER_DEFINED_ATTRIBUTE]; // https://docs.swift.org/swift-book/ReferenceManual/Types.html\n\n  const TYPE = {\n    match: lookahead(/\\b[A-Z]/),\n    relevance: 0,\n    contains: [{\n      // Common Apple frameworks, for relevance boost\n      className: 'type',\n      match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\n    }, {\n      // Type identifier\n      className: 'type',\n      match: typeIdentifier,\n      relevance: 0\n    }, {\n      // Optional type\n      match: /[?!]+/,\n      relevance: 0\n    }, {\n      // Variadic parameter\n      match: /\\.\\.\\./,\n      relevance: 0\n    }, {\n      // Protocol composition\n      match: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\n      relevance: 0\n    }]\n  };\n  const GENERIC_ARGUMENTS = {\n    begin: /</,\n    end: />/,\n    keywords: KEYWORDS,\n    contains: [...COMMENTS, ...KEYWORD_MODES, ...ATTRIBUTES, OPERATOR_GUARD, TYPE]\n  };\n  TYPE.contains.push(GENERIC_ARGUMENTS); // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552\n  // Prevents element names from being highlighted as keywords.\n\n  const TUPLE_ELEMENT_NAME = {\n    match: concat(identifier, /\\s*:/),\n    keywords: \"_|0\",\n    relevance: 0\n  }; // Matches tuples as well as the parameter list of a function type.\n\n  const TUPLE = {\n    begin: /\\(/,\n    end: /\\)/,\n    relevance: 0,\n    keywords: KEYWORDS,\n    contains: ['self', TUPLE_ELEMENT_NAME, ...COMMENTS, ...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS, ...ATTRIBUTES, TYPE]\n  };\n  const GENERIC_PARAMETERS = {\n    begin: /</,\n    end: />/,\n    contains: [...COMMENTS, TYPE]\n  };\n  const FUNCTION_PARAMETER_NAME = {\n    begin: either(lookahead(concat(identifier, /\\s*:/)), lookahead(concat(identifier, /\\s+/, identifier, /\\s*:/))),\n    end: /:/,\n    relevance: 0,\n    contains: [{\n      className: 'keyword',\n      match: /\\b_\\b/\n    }, {\n      className: 'params',\n      match: identifier\n    }]\n  };\n  const FUNCTION_PARAMETERS = {\n    begin: /\\(/,\n    end: /\\)/,\n    keywords: KEYWORDS,\n    contains: [FUNCTION_PARAMETER_NAME, ...COMMENTS, ...KEYWORD_MODES, ...OPERATORS, NUMBER, STRING, ...ATTRIBUTES, TYPE, TUPLE],\n    endsParent: true,\n    illegal: /[\"']/\n  }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362\n\n  const FUNCTION = {\n    match: [/func/, /\\s+/, either(QUOTED_IDENTIFIER.match, identifier, operator)],\n    className: {\n      1: \"keyword\",\n      3: \"title.function\"\n    },\n    contains: [GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE],\n    illegal: [/\\[/, /%/]\n  }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379\n\n  const INIT_SUBSCRIPT = {\n    match: [/\\b(?:subscript|init[?!]?)/, /\\s*(?=[<(])/],\n    className: {\n      1: \"keyword\"\n    },\n    contains: [GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE],\n    illegal: /\\[|%/\n  }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380\n\n  const OPERATOR_DECLARATION = {\n    match: [/operator/, /\\s+/, operator],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    }\n  }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550\n\n  const PRECEDENCEGROUP = {\n    begin: [/precedencegroup/, /\\s+/, typeIdentifier],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    },\n    contains: [TYPE],\n    keywords: [...precedencegroupKeywords, ...literals],\n    end: /}/\n  }; // Add supported submodes to string interpolation.\n\n  for (const variant of STRING.variants) {\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\"); // TODO: Interpolation can contain any expression, so there's room for improvement here.\n\n    interpolation.keywords = KEYWORDS;\n    const submodes = [...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS];\n    interpolation.contains = [...submodes, {\n      begin: /\\(/,\n      end: /\\)/,\n      contains: ['self', ...submodes]\n    }];\n  }\n\n  return {\n    name: 'Swift',\n    keywords: KEYWORDS,\n    contains: [...COMMENTS, FUNCTION, INIT_SUBSCRIPT, {\n      beginKeywords: 'struct protocol class extension enum actor',\n      end: '\\\\{',\n      excludeEnd: true,\n      keywords: KEYWORDS,\n      contains: [hljs.inherit(hljs.TITLE_MODE, {\n        className: \"title.class\",\n        begin: /[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/\n      }), ...KEYWORD_MODES]\n    }, OPERATOR_DECLARATION, PRECEDENCEGROUP, {\n      beginKeywords: 'import',\n      end: /$/,\n      contains: [...COMMENTS],\n      relevance: 0\n    }, ...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS, ...ATTRIBUTES, TYPE, TUPLE]\n  };\n}\n\nmodule.exports = swift;","map":{"version":3,"sources":["D:/workspace_angular/asi/node_modules/highlight.js/lib/languages/swift.js"],"names":["source","re","lookahead","concat","args","joined","map","x","join","stripOptionsFromArgs","opts","length","constructor","Object","splice","either","capture","keywordWrapper","keyword","test","dotKeywords","optionalDotKeywords","keywordTypes","keywords","literals","precedencegroupKeywords","numberSignKeywords","builtIns","operatorHead","operatorCharacter","operator","identifierHead","identifierCharacter","identifier","typeIdentifier","keywordAttributes","availabilityKeywords","swift","hljs","WHITESPACE","match","relevance","BLOCK_COMMENT","COMMENT","contains","COMMENTS","C_LINE_COMMENT_MODE","DOT_KEYWORD","className","KEYWORD_GUARD","PLAIN_KEYWORDS","filter","kw","REGEX_KEYWORDS","KEYWORD","variants","KEYWORDS","$pattern","literal","KEYWORD_MODES","BUILT_IN_GUARD","BUILT_IN","BUILT_INS","OPERATOR_GUARD","OPERATOR","OPERATORS","decimalDigits","hexDigits","NUMBER","ESCAPED_CHARACTER","rawDelimiter","ESCAPED_NEWLINE","INTERPOLATION","label","begin","end","MULTILINE_STRING","SINGLE_LINE_STRING","STRING","QUOTED_IDENTIFIER","IMPLICIT_PARAMETER","PROPERTY_WRAPPER_PROJECTION","IDENTIFIERS","AVAILABLE_ATTRIBUTE","starts","KEYWORD_ATTRIBUTE","USER_DEFINED_ATTRIBUTE","ATTRIBUTES","TYPE","GENERIC_ARGUMENTS","push","TUPLE_ELEMENT_NAME","TUPLE","GENERIC_PARAMETERS","FUNCTION_PARAMETER_NAME","FUNCTION_PARAMETERS","endsParent","illegal","FUNCTION","INIT_SUBSCRIPT","OPERATOR_DECLARATION","PRECEDENCEGROUP","variant","interpolation","find","mode","submodes","name","beginKeywords","excludeEnd","inherit","TITLE_MODE","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @param {string} value\r\n * @returns {RegExp}\r\n * */\r\n\r\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\r\nfunction source(re) {\r\n  if (!re) return null;\r\n  if (typeof re === \"string\") return re;\r\n\r\n  return re.source;\r\n}\r\n\r\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\r\nfunction lookahead(re) {\r\n  return concat('(?=', re, ')');\r\n}\r\n\r\n/**\r\n * @param {...(RegExp | string) } args\r\n * @returns {string}\r\n */\r\nfunction concat(...args) {\r\n  const joined = args.map((x) => source(x)).join(\"\");\r\n  return joined;\r\n}\r\n\r\nfunction stripOptionsFromArgs(args) {\r\n  const opts = args[args.length - 1];\r\n\r\n  if (typeof opts === 'object' && opts.constructor === Object) {\r\n    args.splice(args.length - 1, 1);\r\n    return opts;\r\n  } else {\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Any of the passed expresssions may match\r\n *\r\n * Creates a huge this | this | that | that match\r\n * @param {(RegExp | string)[] } args\r\n * @returns {string}\r\n */\r\nfunction either(...args) {\r\n  const opts = stripOptionsFromArgs(args);\r\n  const joined = '(' +\r\n    (opts.capture ? \"\" : \"?:\") +\r\n    args.map((x) => source(x)).join(\"|\") + \")\";\r\n  return joined;\r\n}\r\n\r\nconst keywordWrapper = keyword => concat(\r\n  /\\b/,\r\n  keyword,\r\n  /\\w$/.test(keyword) ? /\\b/ : /\\B/\r\n);\r\n\r\n// Keywords that require a leading dot.\r\nconst dotKeywords = [\r\n  'Protocol', // contextual\r\n  'Type' // contextual\r\n].map(keywordWrapper);\r\n\r\n// Keywords that may have a leading dot.\r\nconst optionalDotKeywords = [\r\n  'init',\r\n  'self'\r\n].map(keywordWrapper);\r\n\r\n// should register as keyword, not type\r\nconst keywordTypes = [\r\n  'Any',\r\n  'Self'\r\n];\r\n\r\n// Regular keywords and literals.\r\nconst keywords = [\r\n  // strings below will be fed into the regular `keywords` engine while regex\r\n  // will result in additional modes being created to scan for those keywords to\r\n  // avoid conflicts with other rules\r\n  'actor',\r\n  'associatedtype',\r\n  'async',\r\n  'await',\r\n  /as\\?/, // operator\r\n  /as!/, // operator\r\n  'as', // operator\r\n  'break',\r\n  'case',\r\n  'catch',\r\n  'class',\r\n  'continue',\r\n  'convenience', // contextual\r\n  'default',\r\n  'defer',\r\n  'deinit',\r\n  'didSet', // contextual\r\n  'do',\r\n  'dynamic', // contextual\r\n  'else',\r\n  'enum',\r\n  'extension',\r\n  'fallthrough',\r\n  /fileprivate\\(set\\)/,\r\n  'fileprivate',\r\n  'final', // contextual\r\n  'for',\r\n  'func',\r\n  'get', // contextual\r\n  'guard',\r\n  'if',\r\n  'import',\r\n  'indirect', // contextual\r\n  'infix', // contextual\r\n  /init\\?/,\r\n  /init!/,\r\n  'inout',\r\n  /internal\\(set\\)/,\r\n  'internal',\r\n  'in',\r\n  'is', // operator\r\n  'isolated', // contextual\r\n  'nonisolated', // contextual\r\n  'lazy', // contextual\r\n  'let',\r\n  'mutating', // contextual\r\n  'nonmutating', // contextual\r\n  /open\\(set\\)/, // contextual\r\n  'open', // contextual\r\n  'operator',\r\n  'optional', // contextual\r\n  'override', // contextual\r\n  'postfix', // contextual\r\n  'precedencegroup',\r\n  'prefix', // contextual\r\n  /private\\(set\\)/,\r\n  'private',\r\n  'protocol',\r\n  /public\\(set\\)/,\r\n  'public',\r\n  'repeat',\r\n  'required', // contextual\r\n  'rethrows',\r\n  'return',\r\n  'set', // contextual\r\n  'some', // contextual\r\n  'static',\r\n  'struct',\r\n  'subscript',\r\n  'super',\r\n  'switch',\r\n  'throws',\r\n  'throw',\r\n  /try\\?/, // operator\r\n  /try!/, // operator\r\n  'try', // operator\r\n  'typealias',\r\n  /unowned\\(safe\\)/, // contextual\r\n  /unowned\\(unsafe\\)/, // contextual\r\n  'unowned', // contextual\r\n  'var',\r\n  'weak', // contextual\r\n  'where',\r\n  'while',\r\n  'willSet' // contextual\r\n];\r\n\r\n// NOTE: Contextual keywords are reserved only in specific contexts.\r\n// Ideally, these should be matched using modes to avoid false positives.\r\n\r\n// Literals.\r\nconst literals = [\r\n  'false',\r\n  'nil',\r\n  'true'\r\n];\r\n\r\n// Keywords used in precedence groups.\r\nconst precedencegroupKeywords = [\r\n  'assignment',\r\n  'associativity',\r\n  'higherThan',\r\n  'left',\r\n  'lowerThan',\r\n  'none',\r\n  'right'\r\n];\r\n\r\n// Keywords that start with a number sign (#).\r\n// #available is handled separately.\r\nconst numberSignKeywords = [\r\n  '#colorLiteral',\r\n  '#column',\r\n  '#dsohandle',\r\n  '#else',\r\n  '#elseif',\r\n  '#endif',\r\n  '#error',\r\n  '#file',\r\n  '#fileID',\r\n  '#fileLiteral',\r\n  '#filePath',\r\n  '#function',\r\n  '#if',\r\n  '#imageLiteral',\r\n  '#keyPath',\r\n  '#line',\r\n  '#selector',\r\n  '#sourceLocation',\r\n  '#warn_unqualified_access',\r\n  '#warning'\r\n];\r\n\r\n// Global functions in the Standard Library.\r\nconst builtIns = [\r\n  'abs',\r\n  'all',\r\n  'any',\r\n  'assert',\r\n  'assertionFailure',\r\n  'debugPrint',\r\n  'dump',\r\n  'fatalError',\r\n  'getVaList',\r\n  'isKnownUniquelyReferenced',\r\n  'max',\r\n  'min',\r\n  'numericCast',\r\n  'pointwiseMax',\r\n  'pointwiseMin',\r\n  'precondition',\r\n  'preconditionFailure',\r\n  'print',\r\n  'readLine',\r\n  'repeatElement',\r\n  'sequence',\r\n  'stride',\r\n  'swap',\r\n  'swift_unboxFromSwiftValueWithType',\r\n  'transcode',\r\n  'type',\r\n  'unsafeBitCast',\r\n  'unsafeDowncast',\r\n  'withExtendedLifetime',\r\n  'withUnsafeMutablePointer',\r\n  'withUnsafePointer',\r\n  'withVaList',\r\n  'withoutActuallyEscaping',\r\n  'zip'\r\n];\r\n\r\n// Valid first characters for operators.\r\nconst operatorHead = either(\r\n  /[/=\\-+!*%<>&|^~?]/,\r\n  /[\\u00A1-\\u00A7]/,\r\n  /[\\u00A9\\u00AB]/,\r\n  /[\\u00AC\\u00AE]/,\r\n  /[\\u00B0\\u00B1]/,\r\n  /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/,\r\n  /[\\u2016-\\u2017]/,\r\n  /[\\u2020-\\u2027]/,\r\n  /[\\u2030-\\u203E]/,\r\n  /[\\u2041-\\u2053]/,\r\n  /[\\u2055-\\u205E]/,\r\n  /[\\u2190-\\u23FF]/,\r\n  /[\\u2500-\\u2775]/,\r\n  /[\\u2794-\\u2BFF]/,\r\n  /[\\u2E00-\\u2E7F]/,\r\n  /[\\u3001-\\u3003]/,\r\n  /[\\u3008-\\u3020]/,\r\n  /[\\u3030]/\r\n);\r\n\r\n// Valid characters for operators.\r\nconst operatorCharacter = either(\r\n  operatorHead,\r\n  /[\\u0300-\\u036F]/,\r\n  /[\\u1DC0-\\u1DFF]/,\r\n  /[\\u20D0-\\u20FF]/,\r\n  /[\\uFE00-\\uFE0F]/,\r\n  /[\\uFE20-\\uFE2F]/\r\n  // TODO: The following characters are also allowed, but the regex isn't supported yet.\r\n  // /[\\u{E0100}-\\u{E01EF}]/u\r\n);\r\n\r\n// Valid operator.\r\nconst operator = concat(operatorHead, operatorCharacter, '*');\r\n\r\n// Valid first characters for identifiers.\r\nconst identifierHead = either(\r\n  /[a-zA-Z_]/,\r\n  /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/,\r\n  /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/,\r\n  /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/,\r\n  /[\\u1E00-\\u1FFF]/,\r\n  /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/,\r\n  /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/,\r\n  /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/,\r\n  /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/,\r\n  /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/,\r\n  /[\\uFE47-\\uFEFE\\uFF00-\\uFFFD]/ // Should be /[\\uFE47-\\uFFFD]/, but we have to exclude FEFF.\r\n  // The following characters are also allowed, but the regexes aren't supported yet.\r\n  // /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\r\n  // /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\r\n  // /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\r\n  // /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\r\n);\r\n\r\n// Valid characters for identifiers.\r\nconst identifierCharacter = either(\r\n  identifierHead,\r\n  /\\d/,\r\n  /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/\r\n);\r\n\r\n// Valid identifier.\r\nconst identifier = concat(identifierHead, identifierCharacter, '*');\r\n\r\n// Valid type identifier.\r\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\r\n\r\n// Built-in attributes, which are highlighted as keywords.\r\n// @available is handled separately.\r\nconst keywordAttributes = [\r\n  'autoclosure',\r\n  concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/),\r\n  'discardableResult',\r\n  'dynamicCallable',\r\n  'dynamicMemberLookup',\r\n  'escaping',\r\n  'frozen',\r\n  'GKInspectable',\r\n  'IBAction',\r\n  'IBDesignable',\r\n  'IBInspectable',\r\n  'IBOutlet',\r\n  'IBSegueAction',\r\n  'inlinable',\r\n  'main',\r\n  'nonobjc',\r\n  'NSApplicationMain',\r\n  'NSCopying',\r\n  'NSManaged',\r\n  concat(/objc\\(/, identifier, /\\)/),\r\n  'objc',\r\n  'objcMembers',\r\n  'propertyWrapper',\r\n  'requires_stored_property_inits',\r\n  'resultBuilder',\r\n  'testable',\r\n  'UIApplicationMain',\r\n  'unknown',\r\n  'usableFromInline'\r\n];\r\n\r\n// Contextual keywords used in @available and #available.\r\nconst availabilityKeywords = [\r\n  'iOS',\r\n  'iOSApplicationExtension',\r\n  'macOS',\r\n  'macOSApplicationExtension',\r\n  'macCatalyst',\r\n  'macCatalystApplicationExtension',\r\n  'watchOS',\r\n  'watchOSApplicationExtension',\r\n  'tvOS',\r\n  'tvOSApplicationExtension',\r\n  'swift'\r\n];\r\n\r\n/*\r\nLanguage: Swift\r\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\r\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\r\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\r\nWebsite: https://swift.org\r\nCategory: common, system\r\n*/\r\n\r\n/** @type LanguageFn */\r\nfunction swift(hljs) {\r\n  const WHITESPACE = {\r\n    match: /\\s+/,\r\n    relevance: 0\r\n  };\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\r\n  const BLOCK_COMMENT = hljs.COMMENT(\r\n    '/\\\\*',\r\n    '\\\\*/',\r\n    {\r\n      contains: [ 'self' ]\r\n    }\r\n  );\r\n  const COMMENTS = [\r\n    hljs.C_LINE_COMMENT_MODE,\r\n    BLOCK_COMMENT\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\r\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\r\n  const DOT_KEYWORD = {\r\n    match: [\r\n      /\\./,\r\n      either(...dotKeywords, ...optionalDotKeywords)\r\n    ],\r\n    className: {\r\n      2: \"keyword\"\r\n    }\r\n  };\r\n  const KEYWORD_GUARD = {\r\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\r\n    match: concat(/\\./, either(...keywords)),\r\n    relevance: 0\r\n  };\r\n  const PLAIN_KEYWORDS = keywords\r\n    .filter(kw => typeof kw === 'string')\r\n    .concat([ \"_|0\" ]); // seems common, so 0 relevance\r\n  const REGEX_KEYWORDS = keywords\r\n    .filter(kw => typeof kw !== 'string') // find regex\r\n    .concat(keywordTypes)\r\n    .map(keywordWrapper);\r\n  const KEYWORD = {\r\n    variants: [\r\n      {\r\n        className: 'keyword',\r\n        match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\r\n      }\r\n    ]\r\n  };\r\n  // find all the regular keywords\r\n  const KEYWORDS = {\r\n    $pattern: either(\r\n      /\\b\\w+/, // regular keywords\r\n      /#\\w+/ // number keywords\r\n    ),\r\n    keyword: PLAIN_KEYWORDS\r\n      .concat(numberSignKeywords),\r\n    literal: literals\r\n  };\r\n  const KEYWORD_MODES = [\r\n    DOT_KEYWORD,\r\n    KEYWORD_GUARD,\r\n    KEYWORD\r\n  ];\r\n\r\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\r\n  const BUILT_IN_GUARD = {\r\n    // Consume .built_in to prevent highlighting properties and methods.\r\n    match: concat(/\\./, either(...builtIns)),\r\n    relevance: 0\r\n  };\r\n  const BUILT_IN = {\r\n    className: 'built_in',\r\n    match: concat(/\\b/, either(...builtIns), /(?=\\()/)\r\n  };\r\n  const BUILT_INS = [\r\n    BUILT_IN_GUARD,\r\n    BUILT_IN\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\r\n  const OPERATOR_GUARD = {\r\n    // Prevent -> from being highlighting as an operator.\r\n    match: /->/,\r\n    relevance: 0\r\n  };\r\n  const OPERATOR = {\r\n    className: 'operator',\r\n    relevance: 0,\r\n    variants: [\r\n      {\r\n        match: operator\r\n      },\r\n      {\r\n        // dot-operator: only operators that start with a dot are allowed to use dots as\r\n        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\r\n        // characters that may also include dots.\r\n        match: `\\\\.(\\\\.|${operatorCharacter})+`\r\n      }\r\n    ]\r\n  };\r\n  const OPERATORS = [\r\n    OPERATOR_GUARD,\r\n    OPERATOR\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\r\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\r\n  const decimalDigits = '([0-9]_*)+';\r\n  const hexDigits = '([0-9a-fA-F]_*)+';\r\n  const NUMBER = {\r\n    className: 'number',\r\n    relevance: 0,\r\n    variants: [\r\n      // decimal floating-point-literal (subsumes decimal-literal)\r\n      {\r\n        match: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b`\r\n      },\r\n      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\r\n      {\r\n        match: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b`\r\n      },\r\n      // octal-literal\r\n      {\r\n        match: /\\b0o([0-7]_*)+\\b/\r\n      },\r\n      // binary-literal\r\n      {\r\n        match: /\\b0b([01]_*)+\\b/\r\n      }\r\n    ]\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\r\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\r\n    className: 'subst',\r\n    variants: [\r\n      {\r\n        match: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/)\r\n      },\r\n      {\r\n        match: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/)\r\n      }\r\n    ]\r\n  });\r\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\r\n    className: 'subst',\r\n    match: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\r\n  });\r\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\r\n    className: 'subst',\r\n    label: \"interpol\",\r\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\r\n    end: /\\)/\r\n  });\r\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\r\n    begin: concat(rawDelimiter, /\"\"\"/),\r\n    end: concat(/\"\"\"/, rawDelimiter),\r\n    contains: [\r\n      ESCAPED_CHARACTER(rawDelimiter),\r\n      ESCAPED_NEWLINE(rawDelimiter),\r\n      INTERPOLATION(rawDelimiter)\r\n    ]\r\n  });\r\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\r\n    begin: concat(rawDelimiter, /\"/),\r\n    end: concat(/\"/, rawDelimiter),\r\n    contains: [\r\n      ESCAPED_CHARACTER(rawDelimiter),\r\n      INTERPOLATION(rawDelimiter)\r\n    ]\r\n  });\r\n  const STRING = {\r\n    className: 'string',\r\n    variants: [\r\n      MULTILINE_STRING(),\r\n      MULTILINE_STRING(\"#\"),\r\n      MULTILINE_STRING(\"##\"),\r\n      MULTILINE_STRING(\"###\"),\r\n      SINGLE_LINE_STRING(),\r\n      SINGLE_LINE_STRING(\"#\"),\r\n      SINGLE_LINE_STRING(\"##\"),\r\n      SINGLE_LINE_STRING(\"###\")\r\n    ]\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\r\n  const QUOTED_IDENTIFIER = {\r\n    match: concat(/`/, identifier, /`/)\r\n  };\r\n  const IMPLICIT_PARAMETER = {\r\n    className: 'variable',\r\n    match: /\\$\\d+/\r\n  };\r\n  const PROPERTY_WRAPPER_PROJECTION = {\r\n    className: 'variable',\r\n    match: `\\\\$${identifierCharacter}+`\r\n  };\r\n  const IDENTIFIERS = [\r\n    QUOTED_IDENTIFIER,\r\n    IMPLICIT_PARAMETER,\r\n    PROPERTY_WRAPPER_PROJECTION\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\r\n  const AVAILABLE_ATTRIBUTE = {\r\n    match: /(@|#)available/,\r\n    className: \"keyword\",\r\n    starts: {\r\n      contains: [\r\n        {\r\n          begin: /\\(/,\r\n          end: /\\)/,\r\n          keywords: availabilityKeywords,\r\n          contains: [\r\n            ...OPERATORS,\r\n            NUMBER,\r\n            STRING\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  };\r\n  const KEYWORD_ATTRIBUTE = {\r\n    className: 'keyword',\r\n    match: concat(/@/, either(...keywordAttributes))\r\n  };\r\n  const USER_DEFINED_ATTRIBUTE = {\r\n    className: 'meta',\r\n    match: concat(/@/, identifier)\r\n  };\r\n  const ATTRIBUTES = [\r\n    AVAILABLE_ATTRIBUTE,\r\n    KEYWORD_ATTRIBUTE,\r\n    USER_DEFINED_ATTRIBUTE\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\r\n  const TYPE = {\r\n    match: lookahead(/\\b[A-Z]/),\r\n    relevance: 0,\r\n    contains: [\r\n      { // Common Apple frameworks, for relevance boost\r\n        className: 'type',\r\n        match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\r\n      },\r\n      { // Type identifier\r\n        className: 'type',\r\n        match: typeIdentifier,\r\n        relevance: 0\r\n      },\r\n      { // Optional type\r\n        match: /[?!]+/,\r\n        relevance: 0\r\n      },\r\n      { // Variadic parameter\r\n        match: /\\.\\.\\./,\r\n        relevance: 0\r\n      },\r\n      { // Protocol composition\r\n        match: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\r\n        relevance: 0\r\n      }\r\n    ]\r\n  };\r\n  const GENERIC_ARGUMENTS = {\r\n    begin: /</,\r\n    end: />/,\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      ...COMMENTS,\r\n      ...KEYWORD_MODES,\r\n      ...ATTRIBUTES,\r\n      OPERATOR_GUARD,\r\n      TYPE\r\n    ]\r\n  };\r\n  TYPE.contains.push(GENERIC_ARGUMENTS);\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552\r\n  // Prevents element names from being highlighted as keywords.\r\n  const TUPLE_ELEMENT_NAME = {\r\n    match: concat(identifier, /\\s*:/),\r\n    keywords: \"_|0\",\r\n    relevance: 0\r\n  };\r\n  // Matches tuples as well as the parameter list of a function type.\r\n  const TUPLE = {\r\n    begin: /\\(/,\r\n    end: /\\)/,\r\n    relevance: 0,\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      'self',\r\n      TUPLE_ELEMENT_NAME,\r\n      ...COMMENTS,\r\n      ...KEYWORD_MODES,\r\n      ...BUILT_INS,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...IDENTIFIERS,\r\n      ...ATTRIBUTES,\r\n      TYPE\r\n    ]\r\n  };\r\n\r\n  const GENERIC_PARAMETERS = {\r\n    begin: /</,\r\n    end: />/,\r\n    contains: [\r\n      ...COMMENTS,\r\n      TYPE\r\n    ]\r\n  };\r\n  const FUNCTION_PARAMETER_NAME = {\r\n    begin: either(\r\n      lookahead(concat(identifier, /\\s*:/)),\r\n      lookahead(concat(identifier, /\\s+/, identifier, /\\s*:/))\r\n    ),\r\n    end: /:/,\r\n    relevance: 0,\r\n    contains: [\r\n      {\r\n        className: 'keyword',\r\n        match: /\\b_\\b/\r\n      },\r\n      {\r\n        className: 'params',\r\n        match: identifier\r\n      }\r\n    ]\r\n  };\r\n  const FUNCTION_PARAMETERS = {\r\n    begin: /\\(/,\r\n    end: /\\)/,\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      FUNCTION_PARAMETER_NAME,\r\n      ...COMMENTS,\r\n      ...KEYWORD_MODES,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...ATTRIBUTES,\r\n      TYPE,\r\n      TUPLE\r\n    ],\r\n    endsParent: true,\r\n    illegal: /[\"']/\r\n  };\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362\r\n  const FUNCTION = {\r\n    match: [\r\n      /func/,\r\n      /\\s+/,\r\n      either(QUOTED_IDENTIFIER.match, identifier, operator)\r\n    ],\r\n    className: {\r\n      1: \"keyword\",\r\n      3: \"title.function\"\r\n    },\r\n    contains: [\r\n      GENERIC_PARAMETERS,\r\n      FUNCTION_PARAMETERS,\r\n      WHITESPACE\r\n    ],\r\n    illegal: [\r\n      /\\[/,\r\n      /%/\r\n    ]\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379\r\n  const INIT_SUBSCRIPT = {\r\n    match: [\r\n      /\\b(?:subscript|init[?!]?)/,\r\n      /\\s*(?=[<(])/,\r\n    ],\r\n    className: {\r\n      1: \"keyword\"\r\n    },\r\n    contains: [\r\n      GENERIC_PARAMETERS,\r\n      FUNCTION_PARAMETERS,\r\n      WHITESPACE\r\n    ],\r\n    illegal: /\\[|%/\r\n  };\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380\r\n  const OPERATOR_DECLARATION = {\r\n    match: [\r\n      /operator/,\r\n      /\\s+/,\r\n      operator\r\n    ],\r\n    className: {\r\n      1: \"keyword\",\r\n      3: \"title\"\r\n    }\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550\r\n  const PRECEDENCEGROUP = {\r\n    begin: [\r\n      /precedencegroup/,\r\n      /\\s+/,\r\n      typeIdentifier\r\n    ],\r\n    className: {\r\n      1: \"keyword\",\r\n      3: \"title\"\r\n    },\r\n    contains: [ TYPE ],\r\n    keywords: [\r\n      ...precedencegroupKeywords,\r\n      ...literals\r\n    ],\r\n    end: /}/\r\n  };\r\n\r\n  // Add supported submodes to string interpolation.\r\n  for (const variant of STRING.variants) {\r\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\");\r\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\r\n    interpolation.keywords = KEYWORDS;\r\n    const submodes = [\r\n      ...KEYWORD_MODES,\r\n      ...BUILT_INS,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...IDENTIFIERS\r\n    ];\r\n    interpolation.contains = [\r\n      ...submodes,\r\n      {\r\n        begin: /\\(/,\r\n        end: /\\)/,\r\n        contains: [\r\n          'self',\r\n          ...submodes\r\n        ]\r\n      }\r\n    ];\r\n  }\r\n\r\n  return {\r\n    name: 'Swift',\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      ...COMMENTS,\r\n      FUNCTION,\r\n      INIT_SUBSCRIPT,\r\n      {\r\n        beginKeywords: 'struct protocol class extension enum actor',\r\n        end: '\\\\{',\r\n        excludeEnd: true,\r\n        keywords: KEYWORDS,\r\n        contains: [\r\n          hljs.inherit(hljs.TITLE_MODE, {\r\n            className: \"title.class\",\r\n            begin: /[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/\r\n          }),\r\n          ...KEYWORD_MODES\r\n        ]\r\n      },\r\n      OPERATOR_DECLARATION,\r\n      PRECEDENCEGROUP,\r\n      {\r\n        beginKeywords: 'import',\r\n        end: /$/,\r\n        contains: [ ...COMMENTS ],\r\n        relevance: 0\r\n      },\r\n      ...KEYWORD_MODES,\r\n      ...BUILT_INS,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...IDENTIFIERS,\r\n      ...ATTRIBUTES,\r\n      TYPE,\r\n      TUPLE\r\n    ]\r\n  };\r\n}\r\n\r\nmodule.exports = swift;\r\n"]},"metadata":{},"sourceType":"script"}